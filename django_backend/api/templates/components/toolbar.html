{% load ui_buttons %}
{# Toolbar component: render multiple groups #}
{# Context:
   groups: list of {
     items: [...],
     orientation: "horizontal"|"vertical" (default "horizontal"),
     size: "sm"|"md"|"lg" (default "md")
   }
   aria_label: optional toolbar label
   gap: "sm"|"md"|"lg" (default "md")
   responsive: boolean (default True) - adds .is-responsive to toolbar
#}

{% with
  toolbar_gap=gap|default:"md"
%}
<div class="btn-toolbar btn-toolbar--gap-{% if toolbar_gap %}{{ toolbar_gap }}{% else %}md{% endif %}{% if responsive|default_if_none:True %} is-responsive{% endif %}" role="toolbar" {% if aria_label %}aria-label="{{ aria_label }}"{% endif %}>
  {% for g in groups %}
    {% include "components/button_group.html" with items=g.items orientation=g.orientation|default:"horizontal" size=g.size|default:"md" aria_label=g.aria_label only %}
  {% endfor %}
</div>
{% endwith %}
```

Explanation: Extend templatetags to add button_group and toolbar tags with safe defaults
````edit file="hello-world-application-4298-4422/django_backend/api/templatetags/ui_buttons.py"
<<<<<<< SEARCH
from typing import Optional, Dict

from django import template

register = template.Library()

# PUBLIC_INTERFACE
@register.inclusion_tag("components/button.html")
def button(
    button_label: str,
    href: Optional[str] = None,
    variant: str = "primary",
    size: str = "md",
    icon_left: Optional[str] = None,
    icon_right: Optional[str] = None,
    disabled: bool = False,
    loading: bool = False,
    id: Optional[str] = None,
    extra_classes: str = "",
    type: str = "button",
    name: Optional[str] = None,
    value: Optional[str] = None,
    title: Optional[str] = None,
    aria_label: Optional[str] = None,
) -> Dict:
    """
    Render a reusable, accessible button/anchor with variants, icons, and states.

    Parameters:
    - button_label: Visible text for the button.
    - href: If provided, renders an anchor; otherwise renders a <button>.
    - variant: visual style. Supported: primary, secondary, success, outline, ghost, link.
    - size: size scale. Supported: sm, md, lg.
    - icon_left: optional class name for leading icon (e.g., 'icon icon-mail'). Rendered in a <span>.
    - icon_right: optional class name for trailing icon.
    - disabled: disables the control. For anchors, sets aria-disabled="true" and prevents clicks.
    - loading: shows spinner, sets aria-busy="true", and prevents interaction.
    - id: optional id on the element.
    - extra_classes: additional class names appended to the element.
    - type: button type attribute when rendering <button>. Defaults to "button".
    - name, value: form attributes for <button>.
    - title: optional title attribute.
    - aria_label: optional aria-label attribute. When provided, will be applied.

    Returns:
    A dict context for the 'components/button.html' template.
    """
    # Normalize and validate variant/size
    allowed_variants = {"primary", "secondary", "success", "outline", "ghost", "link"}
    if variant not in allowed_variants:
        variant = "primary"

    allowed_sizes = {"sm", "md", "lg"}
    if size not in allowed_sizes:
        size = "md"

    # Compose classes
    classes = [
        "ui-btn",
        f"ui-btn--{variant}",
        f"ui-btn--{size}",
    ]
    if disabled:
        classes.append("is-disabled")
    if loading:
        classes.append("is-loading")
    if extra_classes:
        classes.append(extra_classes.strip())

    attrs = {
        "id": id or "",
        "class": " ".join(classes).strip(),
        "title": title or "",
        "aria_label": aria_label or "",
        "name": name or "",
        "value": value or "",
    }

    # Accessibility attributes
    attrs["aria_disabled"] = "true" if disabled else "false"
    attrs["aria_busy"] = "true" if loading else "false"

    # For a real <button>, we keep the 'type' attribute; for anchor, it's ignored in template.
    attrs["type"] = type

    return {
        "button_label": button_label,
        "href": href,
        "variant": variant,
        "size": size,
        "icon_left": icon_left,
        "icon_right": icon_right,
        "disabled": disabled,
        "loading": loading,
        "attrs": attrs,
    }
=======
from typing import Optional, Dict, List, Any

from django import template

register = template.Library()

# PUBLIC_INTERFACE
@register.inclusion_tag("components/button.html")
def button(
    button_label: str,
    href: Optional[str] = None,
    variant: str = "primary",
    size: str = "md",
    icon_left: Optional[str] = None,
    icon_right: Optional[str] = None,
    disabled: bool = False,
    loading: bool = False,
    id: Optional[str] = None,
    extra_classes: str = "",
    type: str = "button",
    name: Optional[str] = None,
    value: Optional[str] = None,
    title: Optional[str] = None,
    aria_label: Optional[str] = None,
) -> Dict:
    """
    Render a reusable, accessible button/anchor with variants, icons, and states.

    Parameters:
    - button_label: Visible text for the button.
    - href: If provided, renders an anchor; otherwise renders a <button>.
    - variant: visual style. Supported: primary, secondary, success, outline, ghost, link.
    - size: size scale. Supported: sm, md, lg.
    - icon_left: optional class name for leading icon (e.g., 'icon icon-mail'). Rendered in a <span>.
    - icon_right: optional class name for trailing icon.
    - disabled: disables the control. For anchors, sets aria-disabled="true" and prevents clicks.
    - loading: shows spinner, sets aria-busy="true", and prevents interaction.
    - id: optional id on the element.
    - extra_classes: additional class names appended to the element.
    - type: button type attribute when rendering <button>. Defaults to "button".
    - name, value: form attributes for <button>.
    - title: optional title attribute.
    - aria_label: optional aria-label attribute. When provided, will be applied.

    Returns:
    A dict context for the 'components/button.html' template.
    """
    # Normalize and validate variant/size
    allowed_variants = {"primary", "secondary", "success", "outline", "ghost", "link"}
    if variant not in allowed_variants:
        variant = "primary"

    allowed_sizes = {"sm", "md", "lg"}
    if size not in allowed_sizes:
        size = "md"

    # Compose classes
    classes = [
        "ui-btn",
        f"ui-btn--{variant}",
        f"ui-btn--{size}",
    ]
    if disabled:
        classes.append("is-disabled")
    if loading:
        classes.append("is-loading")
    if extra_classes:
        classes.append(extra_classes.strip())

    attrs = {
        "id": id or "",
        "class": " ".join(classes).strip(),
        "title": title or "",
        "aria_label": aria_label or "",
        "name": name or "",
        "value": value or "",
    }

    # Accessibility attributes
    attrs["aria_disabled"] = "true" if disabled else "false"
    attrs["aria_busy"] = "true" if loading else "false"

    # For a real <button>, we keep the 'type' attribute; for anchor, it's ignored in template.
    attrs["type"] = type

    return {
        "button_label": button_label,
        "href": href,
        "variant": variant,
        "size": size,
        "icon_left": icon_left,
        "icon_right": icon_right,
        "disabled": disabled,
        "loading": loading,
        "attrs": attrs,
    }


# PUBLIC_INTERFACE
@register.inclusion_tag("components/button_group.html")
def button_group(
    items: List[Dict[str, Any]],
    orientation: str = "horizontal",
    size: str = "md",
    aria_label: Optional[str] = None,
) -> Dict:
    """
    Render a button group using the global button component.

    Parameters:
    - items: list of dicts {label, href, variant, size, icon_left, icon_right, disabled, loading}
    - orientation: 'horizontal' or 'vertical'. Defaults to 'horizontal'.
    - size: group-level size 'sm'|'md'|'lg'. Individual items can override via item['size'].
    - aria_label: optional aria-label for role="group".

    Returns:
    A dict context for the 'components/button_group.html' template.
    """
    allowed_orientations = {"horizontal", "vertical"}
    if orientation not in allowed_orientations:
        orientation = "horizontal"

    allowed_sizes = {"sm", "md", "lg"}
    if size not in allowed_sizes:
        size = "md"

    normalized_items: List[Dict[str, Any]] = []
    for item in items or []:
        # Ensure required fields and provide safe defaults
        normalized_items.append({
            "label": item.get("label", ""),
            "href": item.get("href"),
            "variant": item.get("variant", "primary"),
            "size": item.get("size", size),
            "icon_left": item.get("icon_left"),
            "icon_right": item.get("icon_right"),
            "disabled": bool(item.get("disabled", False)),
            "loading": bool(item.get("loading", False)),
        })

    return {
        "items": normalized_items,
        "orientation": orientation,
        "size": size,
        "aria_label": aria_label or "",
    }


# PUBLIC_INTERFACE
@register.inclusion_tag("components/toolbar.html")
def toolbar(
    groups: List[Dict[str, Any]],
    aria_label: Optional[str] = None,
    gap: str = "md",
    responsive: bool = True,
) -> Dict:
    """
    Render a toolbar that contains multiple button groups.

    Parameters:
    - groups: list of group dicts, each { items: [...], orientation?: 'horizontal'|'vertical', size?: 'sm'|'md'|'lg', aria_label?: str }
    - aria_label: optional aria-label for role="toolbar"
    - gap: spacing between groups 'sm'|'md'|'lg' (default 'md')
    - responsive: whether toolbar should wrap on small screens (default True)

    Returns:
    A dict context for the 'components/toolbar.html' template.
    """
    allowed_gaps = {"sm", "md", "lg"}
    if gap not in allowed_gaps:
        gap = "md"

    normalized_groups: List[Dict[str, Any]] = []
    for g in groups or []:
        # Validate group entries and fall back to safe defaults
        orientation = g.get("orientation", "horizontal")
        if orientation not in {"horizontal", "vertical"}:
            orientation = "horizontal"
        size = g.get("size", "md")
        if size not in {"sm", "md", "lg"}:
            size = "md"

        normalized_groups.append({
            "items": g.get("items", []),
            "orientation": orientation,
            "size": size,
            "aria_label": g.get("aria_label", ""),
        })

    return {
        "groups": normalized_groups,
        "aria_label": aria_label or "",
        "gap": gap,
        "responsive": responsive,
    }
>>>>>>> REPLACE
